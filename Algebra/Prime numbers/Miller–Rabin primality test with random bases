# code - 
#include <bits/stdc++.h>
using namespace std;
using u64 = uint64_t;
using u128 = __uint128_t;

// Perform modular exponentiation (a^d mod n)
u64 modpow(u64 a, u64 d, u64 n) {
    u64 res = 1;
    while (d) {
        if (d & 1) res = (u128)res * a % n;
        a = (u128)a * a % n;
        d >>= 1;
    }
    return res;
}

// Miller-Rabin primality test with random bases
bool isPrime(u64 n, int iter = 10) {
    if (n < 2) return false;
    if (n <= 3) return true;
    if (n % 2 == 0) return false;

    // write n-1 as d*2^s
    u64 s = 0, d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        s++;
    }

    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
    uniform_int_distribution<u64> dist(2, n - 2);

    for (int i = 0; i < iter; i++) {
        u64 a = dist(rng);
        u64 x = modpow(a, d, n);
        if (x == 1 || x == n - 1) continue;

        bool composite = true;
        for (u64 r = 1; r < s; r++) {
            x = (u128)x * x % n;
            if (x == n - 1) {
                composite = false;
                break;
            }
        }
        if (composite) return false;
    }
    return true;
}

int main() {
    u64 n;
    cout << "Enter a number: ";
    cin >> n;

    if (isPrime(n)) {
        cout << n << " is prime.\n";
    } else {
        cout << n << " is composite.\n";
    }
    return 0;
}
